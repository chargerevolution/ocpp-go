// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package NotifyEventRequest

import "fmt"
import "encoding/json"
import "reflect"

// A physical or logical component
//
type ComponentType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty"`

	// Evse corresponds to the JSON schema field "evse".
	Evse *EVSEType `json:"evse,omitempty" yaml:"evse,omitempty"`

	// Name of instance in case the component exists as multiple instances. Case
	// Insensitive. strongly advised to use Camel Case.
	//
	Instance *string `json:"instance,omitempty" yaml:"instance,omitempty"`

	// Name of the component. Name should be taken from the list of standardized
	// component names whenever possible. Case Insensitive. strongly advised to use
	// Camel Case.
	//
	Name string `json:"name" yaml:"name"`
}

// This class does not get 'AdditionalProperties = false' in the schema generation,
// so it can be extended with arbitrary JSON properties to allow adding custom
// data.
type CustomDataType struct {
	// VendorId corresponds to the JSON schema field "vendorId".
	VendorId string `json:"vendorId" yaml:"vendorId"`
}

// EVSE
// urn:x-oca:ocpp:uid:2:233123
// Electric Vehicle Supply Equipment
//
type EVSEType struct {
	// An id to designate a specific connector (on an EVSE) by connector index number.
	//
	ConnectorId *int `json:"connectorId,omitempty" yaml:"connectorId,omitempty"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty"`

	// Identified_ Object. MRID. Numeric_ Identifier
	// urn:x-enexis:ecdm:uid:1:569198
	// EVSE Identifier. This contains a number (&gt; 0) designating an EVSE of the
	// Charging Station.
	//
	Id int `json:"id" yaml:"id"`
}

// Class to report an event notification for a component-variable.
//
type EventDataType struct {
	// Actual value (_attributeType_ Actual) of the variable.
	//
	// The Configuration Variable
	// &lt;&lt;configkey-reporting-value-size,ReportingValueSize&gt;&gt; can be used
	// to limit GetVariableResult.attributeValue, VariableAttribute.value and
	// EventData.actualValue. The max size of these values will always remain equal.
	//
	//
	ActualValue string `json:"actualValue" yaml:"actualValue"`

	// Refers to the Id of an event that is considered to be the cause for this event.
	//
	//
	Cause *int `json:"cause,omitempty" yaml:"cause,omitempty"`

	// _Cleared_ is set to true to report the clearing of a monitored situation, i.e.
	// a 'return to normal'.
	//
	//
	Cleared *bool `json:"cleared,omitempty" yaml:"cleared,omitempty"`

	// Component corresponds to the JSON schema field "component".
	Component ComponentType `json:"component" yaml:"component"`

	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty"`

	// Identifies the event. This field can be referred to as a cause by other events.
	//
	//
	EventId int `json:"eventId" yaml:"eventId"`

	// EventNotificationType corresponds to the JSON schema field
	// "eventNotificationType".
	EventNotificationType EventNotificationEnumType `json:"eventNotificationType" yaml:"eventNotificationType"`

	// Technical (error) code as reported by component.
	//
	TechCode *string `json:"techCode,omitempty" yaml:"techCode,omitempty"`

	// Technical detail information as reported by component.
	//
	TechInfo *string `json:"techInfo,omitempty" yaml:"techInfo,omitempty"`

	// Timestamp of the moment the report was generated.
	//
	Timestamp string `json:"timestamp" yaml:"timestamp"`

	// If an event notification is linked to a specific transaction, this field can be
	// used to specify its transactionId.
	//
	TransactionId *string `json:"transactionId,omitempty" yaml:"transactionId,omitempty"`

	// Trigger corresponds to the JSON schema field "trigger".
	Trigger EventTriggerEnumType `json:"trigger" yaml:"trigger"`

	// Variable corresponds to the JSON schema field "variable".
	Variable VariableType `json:"variable" yaml:"variable"`

	// Identifies the VariableMonitoring which triggered the event.
	//
	VariableMonitoringId *int `json:"variableMonitoringId,omitempty" yaml:"variableMonitoringId,omitempty"`
}

type EventNotificationEnumType string

const EventNotificationEnumTypeCustomMonitor EventNotificationEnumType = "CustomMonitor"
const EventNotificationEnumTypeHardWiredMonitor EventNotificationEnumType = "HardWiredMonitor"
const EventNotificationEnumTypeHardWiredNotification EventNotificationEnumType = "HardWiredNotification"
const EventNotificationEnumTypePreconfiguredMonitor EventNotificationEnumType = "PreconfiguredMonitor"

type EventNotificationEnumType_1 string

const EventNotificationEnumType_1_CustomMonitor EventNotificationEnumType_1 = "CustomMonitor"
const EventNotificationEnumType_1_HardWiredMonitor EventNotificationEnumType_1 = "HardWiredMonitor"
const EventNotificationEnumType_1_HardWiredNotification EventNotificationEnumType_1 = "HardWiredNotification"
const EventNotificationEnumType_1_PreconfiguredMonitor EventNotificationEnumType_1 = "PreconfiguredMonitor"

type EventTriggerEnumType string

const EventTriggerEnumTypeAlerting EventTriggerEnumType = "Alerting"
const EventTriggerEnumTypeDelta EventTriggerEnumType = "Delta"
const EventTriggerEnumTypePeriodic EventTriggerEnumType = "Periodic"

type EventTriggerEnumType_1 string

const EventTriggerEnumType_1_Alerting EventTriggerEnumType_1 = "Alerting"
const EventTriggerEnumType_1_Delta EventTriggerEnumType_1 = "Delta"
const EventTriggerEnumType_1_Periodic EventTriggerEnumType_1 = "Periodic"

type NotifyEventRequestJson struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty"`

	// EventData corresponds to the JSON schema field "eventData".
	EventData []EventDataType `json:"eventData" yaml:"eventData"`

	// Timestamp of the moment this message was generated at the Charging Station.
	//
	GeneratedAt string `json:"generatedAt" yaml:"generatedAt"`

	// Sequence number of this message. First message starts at 0.
	//
	SeqNo int `json:"seqNo" yaml:"seqNo"`

	// “to be continued” indicator. Indicates whether another part of the report
	// follows in an upcoming notifyEventRequest message. Default value when omitted
	// is false.
	//
	Tbc bool `json:"tbc,omitempty" yaml:"tbc,omitempty"`
}

// Reference key to a component-variable.
//
type VariableType struct {
	// CustomData corresponds to the JSON schema field "customData".
	CustomData *CustomDataType `json:"customData,omitempty" yaml:"customData,omitempty"`

	// Name of instance in case the variable exists as multiple instances. Case
	// Insensitive. strongly advised to use Camel Case.
	//
	Instance *string `json:"instance,omitempty" yaml:"instance,omitempty"`

	// Name of the variable. Name should be taken from the list of standardized
	// variable names whenever possible. Case Insensitive. strongly advised to use
	// Camel Case.
	//
	Name string `json:"name" yaml:"name"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventDataType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["actualValue"]; !ok || v == nil {
		return fmt.Errorf("field actualValue in EventDataType: required")
	}
	if v, ok := raw["component"]; !ok || v == nil {
		return fmt.Errorf("field component in EventDataType: required")
	}
	if v, ok := raw["eventId"]; !ok || v == nil {
		return fmt.Errorf("field eventId in EventDataType: required")
	}
	if v, ok := raw["eventNotificationType"]; !ok || v == nil {
		return fmt.Errorf("field eventNotificationType in EventDataType: required")
	}
	if v, ok := raw["timestamp"]; !ok || v == nil {
		return fmt.Errorf("field timestamp in EventDataType: required")
	}
	if v, ok := raw["trigger"]; !ok || v == nil {
		return fmt.Errorf("field trigger in EventDataType: required")
	}
	if v, ok := raw["variable"]; !ok || v == nil {
		return fmt.Errorf("field variable in EventDataType: required")
	}
	type Plain EventDataType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EventDataType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventNotificationEnumType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventNotificationEnumType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventNotificationEnumType_1, v)
	}
	*j = EventNotificationEnumType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VariableType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in VariableType: required")
	}
	type Plain VariableType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = VariableType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventTriggerEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventTriggerEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventTriggerEnumType, v)
	}
	*j = EventTriggerEnumType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventNotificationEnumType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventNotificationEnumType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventNotificationEnumType, v)
	}
	*j = EventNotificationEnumType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ComponentType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["name"]; !ok || v == nil {
		return fmt.Errorf("field name in ComponentType: required")
	}
	type Plain ComponentType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ComponentType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EVSEType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		return fmt.Errorf("field id in EVSEType: required")
	}
	type Plain EVSEType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = EVSEType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *CustomDataType) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["vendorId"]; !ok || v == nil {
		return fmt.Errorf("field vendorId in CustomDataType: required")
	}
	type Plain CustomDataType
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = CustomDataType(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EventTriggerEnumType_1) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EventTriggerEnumType_1 {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EventTriggerEnumType_1, v)
	}
	*j = EventTriggerEnumType_1(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NotifyEventRequestJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["eventData"]; !ok || v == nil {
		return fmt.Errorf("field eventData in NotifyEventRequestJson: required")
	}
	if v, ok := raw["generatedAt"]; !ok || v == nil {
		return fmt.Errorf("field generatedAt in NotifyEventRequestJson: required")
	}
	if v, ok := raw["seqNo"]; !ok || v == nil {
		return fmt.Errorf("field seqNo in NotifyEventRequestJson: required")
	}
	type Plain NotifyEventRequestJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.EventData) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "eventData", 1)
	}
	if v, ok := raw["tbc"]; !ok || v == nil {
		plain.Tbc = false
	}
	*j = NotifyEventRequestJson(plain)
	return nil
}

var enumValues_EventNotificationEnumType = []interface{}{
	"HardWiredNotification",
	"HardWiredMonitor",
	"PreconfiguredMonitor",
	"CustomMonitor",
}
var enumValues_EventNotificationEnumType_1 = []interface{}{
	"HardWiredNotification",
	"HardWiredMonitor",
	"PreconfiguredMonitor",
	"CustomMonitor",
}
var enumValues_EventTriggerEnumType = []interface{}{
	"Alerting",
	"Delta",
	"Periodic",
}
var enumValues_EventTriggerEnumType_1 = []interface{}{
	"Alerting",
	"Delta",
	"Periodic",
}
